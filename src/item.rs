use core::str::Split;
use std::fmt::Formatter;
use std::collections::HashMap;
use rand::Rng;

use crate::inventory::Slot;
use crate::read_lines;
use crate::parse_rgba;

#[derive(Clone, Debug, PartialEq)]
pub enum Activation
{
    None,
    Fireball,
}


#[derive(Clone, Debug, PartialEq)]
pub enum DropEffect
{
    None,
    EnchantFireball,
}


#[derive(Clone, Debug, PartialEq)]
pub enum ItemKind
{
    Misc,
    Wand,
    Ring,
    Scroll,
    Currency
}


#[derive(Debug)]
pub struct Item 
{   
    // the ID must be unique in a game
    pub id: u64,

    pub key: String,              // for prototype lookup
    pub singular: String,         // name for stack size == 1
    pub plural: String,           // name for stack size >= 2
    pub mods: Vec<Mod>,
    
    pub inventory_tile_id: usize,
    pub inventory_w: i32,
    pub inventory_h: i32,
    pub inventory_scale: f32,
    pub map_tile_id: usize,
    pub map_scale: f32,
    pub color: [f32; 4],
    pub ilvl: u32,
    pub kind: ItemKind,
    pub stack_size: u32,         // some items can be stacked and must have a stack count
    pub max_stack_size: u32,
    pub activation: Activation,
    pub drop_effect: DropEffect,

    pub description: String,
}


impl Item 
{
    pub fn name(&self) -> String 
    {
        if self.stack_size == 1 {
            return self.singular.to_string();
        }
        else {
            if self.plural.len() > 0 {
                return self.stack_size.to_string() + " " + &self.plural;
            }
        }

        return self.singular.to_string();
    }

    
    pub fn get_attribute_total_mod(&self, attribute: Attribute) -> f32 
    {
        let mut sum: f32 = 0.0;

        for m in &self.mods {
            if m.attribute == attribute {
                sum = sum + m.min_value as f32;
            }            
        }
        
        sum
    }
    

    pub fn calc_image_offset_for_stack_size(stack_size: u32) -> usize 
    {
        match stack_size {
            0 => 0,    
            1 => 0,    
            2 => 1 * 2,
            3 => 2 * 2,
            4 .. 50 => 3 * 2,
            50 .. 200 => 4 * 2,
            200 .. 500 => 5 * 2,
            _ => 6 * 2,
        }
    }


    pub fn print_debug(&self) 
    {
        println!("{}", self.name());
    }
}


pub struct ItemFactory
{
    next_id: u64,

    proto_items: HashMap<String, Item>,
}


impl ItemFactory {
    pub fn new() -> ItemFactory 
    {
        let proto_items = read_proto_items();
        
        ItemFactory {
            next_id: 0,
            proto_items,
        }
    }


    pub fn create<R: Rng + ?Sized>(&mut self, key: &str, rng: &mut R) -> Item 
    {
        let id = self.next_id;
        self.next_id += 1;
        
        let proto = self.proto_items.get(key).unwrap();

        Item {
            id, 
            key: proto.key.to_string(),
            singular: proto.singular.to_string(),
            plural: proto.plural.to_string(),
            mods: process_proto_mods(&proto.mods, rng), // proto.mods.clone(),

            inventory_tile_id: proto.inventory_tile_id,
            inventory_w: proto.inventory_w,
            inventory_h: proto.inventory_h,
            inventory_scale: proto.inventory_scale,
            map_scale: proto.map_scale,
            color: proto.color,
            ilvl: proto.ilvl,
            kind: proto.kind.clone(),
        
            map_tile_id: proto.map_tile_id,
            stack_size: 1,
            max_stack_size: proto.max_stack_size,
            activation: proto.activation.clone(),
            drop_effect: proto.drop_effect.clone(),
            description: proto.description.to_string(),
        }
    }


    pub fn create_random<R: Rng + ?Sized>(&mut self, rng: &mut R, area_level: u32) -> Item
    {
        let mut matches = Vec::with_capacity(self.proto_items.len());

        for (_key, proto) in &self.proto_items {
            // ilvl 0 means "do not generate randomly"
            // these items can still be generated by their key
            if proto.ilvl > 0 && proto.ilvl >= area_level {
                matches.push(proto.key.clone());
            }
        }

        // pick a random one
        let index = rng.random_range(0 .. matches.len());

        self.create(&matches[index], rng)
    }
}


fn read_proto_items() -> HashMap<String, Item> 
{
    let lines = read_lines("resources/items/items.csv");
    let mut proto_items: HashMap<String, Item> = HashMap::new();

    for i in 1..lines.len() {
        let mut parts = lines[i].split(",");
        let key = parts.next().unwrap().to_string();
        
        // ignore empty lines, they are just to separate sections
        if key.len() > 0 {
            proto_items.insert(
                key.to_string(),
                Item {
                    id: 0,      // just a placeholder in case of item prototypes.
                    key,
                    singular: parts.next().unwrap().to_string(),
                    plural:  parts.next().unwrap().to_string(),
                    inventory_tile_id: parts.next().unwrap().parse::<usize>().unwrap(),
                    map_tile_id: parts.next().unwrap().parse::<usize>().unwrap(),
                    inventory_w: parts.next().unwrap().parse::<i32>().unwrap(),
                    inventory_h: parts.next().unwrap().parse::<i32>().unwrap(),
                    inventory_scale: parts.next().unwrap().parse::<f32>().unwrap(),
                    map_scale: parts.next().unwrap().parse::<f32>().unwrap(),
                    color: parse_rgba(parts.next().unwrap()),
                    ilvl: parts.next().unwrap().parse::<u32>().unwrap(),
                    kind: parse_item_type(parts.next().unwrap()),
                    stack_size: 1,
                    max_stack_size: parts.next().unwrap().parse::<u32>().unwrap(),
                    drop_effect: parse_drop_effect(parts.next().unwrap()),
                    mods: parse_mods(&mut parts),
                    activation: Activation::None,
                    description: parts.next().unwrap().to_string(),
                }
            );
        }
    }

    proto_items
}


fn calc_slot(v: i32) -> Slot 
{
    match v {
        0 => Slot::OnCursor,
        1 => Slot::Bag,
        2 => Slot::Stash,
        3 => Slot::Head,
        4 => Slot::Body,
        5 => Slot::LHand,
        6 => Slot::RHand,
        7 => Slot::Amulet,
        8 => Slot::LRing,
        9 => Slot::RRing,
        _ => {
            println!("calc_slot: Cannot find slot for input value {}, using Slot::Bag.", v);
            Slot::Bag
        }
    }
}


fn parse_mods(parts: &mut Split<&str>) -> Vec<Mod>
{
    let mut result = Vec::new();

    loop {
        let key = parts.next();
        if key.is_some() {
            let key = key.unwrap();

            match key {
                "spell_dam" => {
                    result.push(parse_mod(parts.next(), Attribute::SpellDamage, Unit::Integer));
                }
                "res_fire" => {
                    result.push(parse_mod(parts.next(), Attribute::ResFire, Unit::Percent));
                }
                "res_light" => {
                    result.push(parse_mod(parts.next(), Attribute::ResLight, Unit::Percent));
                }
                "res_cold" => {
                    result.push(parse_mod(parts.next(), Attribute::ResCold, Unit::Percent));
                }
                "info" => {
                    // info must be the last key and it's not a mod, 
                    // so we stop parsing mods here
                    break;
                }
                "" => {
                    // end of data
                    break;
                }
                _ => {
                    println!("parse_mods: unknown modifier key found: '{}'", key);
                } 
            }
        }
        else {
            // out of data
            break;
        }
    }

    result
}


fn parse_mod(input: Option<&str>, attribute: Attribute, unit: Unit) -> Mod 
{
    let (min_value, max_value) = parse_range(input.unwrap());

    Mod { 
        attribute,
        min_value,
        max_value,
        unit,
    }
}


fn parse_range(input: &str) -> (i32, i32) 
{
    if input.contains("-") {
        let mut parts = input.split("-");
        let min_value = parts.next().unwrap().parse::<i32>().unwrap();
        let max_value = parts.next().unwrap().parse::<i32>().unwrap();
        (min_value, max_value)
    }
    else {
        let value = input.parse::<i32>().unwrap();
        (value, value)
    }
}


fn parse_drop_effect(input: &str) -> DropEffect
{
    if "enchant_fireball" == input {
        return DropEffect::EnchantFireball
    }
    else {
        return DropEffect::None
    }
}


fn parse_item_type(input: &str) -> ItemKind
{
    if "wand" == input {
        return ItemKind::Wand;
    }
    else if "ring" == input {
        return ItemKind::Wand;
    }
    else if "scroll" == input {
        return ItemKind::Wand;
    }
    else if "currency" == input {
        return ItemKind::Currency;
    }
    else {
        println!("parse_item_type: Unknown item type '{}'", input);
        return ItemKind::Misc;
    }
}


#[allow(dead_code)]
#[derive(PartialEq, Eq, Debug, Clone)]
pub enum Attribute {

    Agility,
    Armor,
    Speed,
    PhysicalDamage,
    SpellDamage,
    ResFire,
    ResLight,
    ResCold,
}


impl std::fmt::Display for Attribute 
{
    fn fmt(&self, f: &mut Formatter<'_>) -> Result<(), std::fmt::Error> {

        let name = match self {
            Attribute::Agility => "Agility",
            Attribute::Armor => "Armor",
            Attribute::Speed => "Speed",
            Attribute::PhysicalDamage => "Physical Damage",
            Attribute::SpellDamage => "Added Spell Damage",
            Attribute::ResFire => "Fire Resistance",
            Attribute::ResLight => "Lightning Resistance",
            Attribute::ResCold => "Cold Resistance",
        };

        write!(f, "{}", name)
    }
}


#[derive(PartialEq, Debug, Clone)]
pub enum Unit {
    Percent,
    Integer,
}


impl std::fmt::Display for Unit {
    fn fmt(&self, f: &mut Formatter<'_>) -> Result<(), std::fmt::Error> {

        let name = match self {
            Unit::Percent => "Percent",
            Unit::Integer => "Integer",
        };

        write!(f, "{}", name)
    }
}


#[derive(Debug, Clone)]
pub struct Mod {
    pub attribute: Attribute,
    pub min_value: i32,
    pub max_value: i32,
    pub unit: Unit,
}


fn process_proto_mods<R: Rng + ?Sized>(mods: &Vec<Mod>, rng: &mut R) -> Vec<Mod>
{
    let mut result = Vec::with_capacity(mods.len());

    for modifier in mods {

        if modifier.attribute == Attribute::ResFire || 
           modifier.attribute == Attribute::ResLight ||
           modifier.attribute == Attribute::ResCold {
            // the proto mod is a range, we need to pick one value
            // from that range to produce a concrete mod for our item
            result.push(random_from_range(modifier, rng));
        }
        else {
            result.push(modifier.clone());
        }
    }


    result
}


fn random_from_range<R: Rng + ?Sized>(modifier: &Mod, rng: &mut R) -> Mod 
{
    let mut new = modifier.clone();
    let actual_value = rng.random_range(modifier.min_value .. modifier.max_value);
    new.min_value = actual_value;
    new.max_value = actual_value;

    new
}